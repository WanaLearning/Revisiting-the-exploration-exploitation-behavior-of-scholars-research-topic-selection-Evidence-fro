# -*- coding: utf-8 -*-
"""
Created on Thu Aug 12 17:14:26 2021

This file reproduces the MinVolEllips algorithm in MATLAB language into Python language

@author: ShengzhiHuang
"""
import numpy as np


def GenerateSampleData(d=2, N=10):
    # generate data points (d x N)
    mu = np.random.uniform(0, 1, d)
    sigma = np.eye(d) * np.random.uniform(0, 1, d)
    P = np.random.multivariate_normal(mu, sigma, N)
    P = np.transpose(P)
    return P


def CheckDegenerate(P):
    '''
    Check whether the following two conditions are met:
    (1) the numbder of data points > the dimension of each data point
    i.e. N > d
    (2) Rank(P) == the dimension of each data point (full rank)
    i.e. Rank(P) == d
    
    If either of the above conditions is not met, the situation degenerates
    reference: "How Quantifying the Shape of Stories Predicts Their Success"
    
    Parameters
    ----------
    P : np.array()
        d x N matrix.

    Returns
    -------
    None.

    '''
    d, N = P.shape
    if N > d and np.linalg.matrix_rank(P) == d:
        new_P = P
    else:
        # Step 1. centers all the points at an arbitary point (the last point).
        Y = P[:, :-1] - P[:, -1].reshape(-1, 1)
        # Step 2. singular value decomposition of the matrix Y.
        S, Sigma, Vt = np.linalg.svd(Y)
        
        Sigma_Matrix = np.zeros(Y.shape)
        for i, sig in enumerate(Sigma):
            Sigma_Matrix[i][i] = sig
        # Y_rep = np.dot(np.dot(S, Sigma_Matrix), Vt)
        
        S1 = S[:, :len(Sigma)]
        # Sigma_Matrix_NoneZero = np.diag(Sigma)
        # Y_rep = np.dot(np.dot(S1, Sigma_Matrix_NoneZero), Vt)
        
        # Step 3. the columns of S1 forms an basis of the subspace
        new_P = np.dot(np.transpose(S1), Y)
        origin = np.zeros(new_P.shape[0]).reshape(-1, 1)
        new_P = np.concatenate((new_P, origin), axis=-1)

        d, N = new_P.shape
        
        if N > d and np.linalg.matrix_rank(new_P) == d:
           # print("Projection success")
           pass
        else:
           print("Projection error")
           
    return new_P


def MinVolEllipse(P, tolerance = 0.01):
    '''
    Finds the minimum volume enclsing ellipsoid (MVEE) of a set of data
    points stored in matrix P.
    
    reference: "MINIMUM VOLUME ENCLOSING ELLIPSOIDS"
    
    Parameters
    ----------
    P : np.array()
        d x N matrix.
    tolerance : float, optional
        error in the solution with respect to the optimal value. 
        The default is 0.01.

    Returns
    -------
    A : np.array()
        (d x d) matrix of the ellipse equation in the 'center form'.
        (x-c)' * A * (x-c) = 1 
    c : np.array()
        'd' dimensional vector as the center of the ellipse.

    '''
    # d: the dimension of each point; N: number of data points
    d, N = P.shape
    Q = np.zeros((d+1, N))
    Q[0:d, :] = P[:, :]
    Q[d, :] =  np.ones(N)
    
    # initializations
    count = 1
    err = 1
    u = (1 / N) * np.ones(N)
    # u = u.reshape(-1, 1)
    
    # % Khachiyan Algorithm
    max_count = 2e2
    count = 0
    while err > tolerance and count < max_count:
        # X = Q * diag(u) * Q'
        X = np.dot(np.dot(Q, np.diag(u)), np.transpose(Q))
        # M = diag(Q' * inverse(X) * Q)
        M = np.diag(np.dot(np.dot(np.transpose(Q), np.linalg.inv(X)), Q))
        maximum, j = np.max(M), np.argmax(M)
        step_size = (maximum - d - 1) / ((d + 1) * (maximum - 1))
        new_u = (1 - step_size) * u
        new_u[j] = new_u[j] + step_size
        count = count + 1
        # caculate norm2 between new_u and u
        err = np.linalg.norm(new_u - u);      
        u = new_u
        count += 1
    #     
    U = np.diag(u)
    #the A matrix for the ellipse
    A = (1 / d) * np.linalg.inv(np.dot(np.dot(P, U), np.transpose(P)) - np.dot(np.dot(P, u).reshape(-1, 1), np.dot(P, u).reshape(1, -1)))
    # center of the ellipse 
    c = np.dot(P, u)
    return A, c


def VolumeMetrics(A):
    '''
    # we use the geometric mean (rather than the product)
    # of the lengths of the axes of the minimum-volume ellipsoid
    # as our normalized measure of volume.

    Parameters
    ----------
    A : np.array()
        (d x d) matrix of the ellipse equation in the 'center form'.

    Returns
    -------
    metrics : float
         geometric mean of axe.

    '''
    
    # eigenvalue:
    eig_value, eig_vec = np.linalg.eig(A)
   
    # axe_length: 
    # The lengths of the axes of the ellipsoid are given by
    # the inverse of the square root of the eigenvalues.
    axe_len = pow(eig_value, -1/2)
    
    # the geometric mean:
    n = len(axe_len)
    metrics = 1
    for i in axe_len:
        metrics *= i
    metrics = pow(metrics, 1/n)
    
    return metrics, axe_len


def CaculateVolumeMetrics(P):
    d, N = P.shape
    
    if N < 2:
        # 文章少于3个fos, 不构成体积指标
        # 文章少于2个fos, 不构成体积指标 2022-6-2
        metrics = 0
    else:
        # 检查是否需要degenerate
        new_P = CheckDegenerate(P)
        # 计算椭圆
        A, c = MinVolEllipse(new_P)
        # 计算Volume指标
        metrics, axe_len = VolumeMetrics(A)
        
    return metrics


# P = GenerateSampleData(d=64, N=2)
