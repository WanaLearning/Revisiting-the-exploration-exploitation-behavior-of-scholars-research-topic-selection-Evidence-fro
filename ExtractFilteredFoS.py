#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Mar 30 19:24:29 2022

@author: aixuexi
"""
import os
import pickle
import json
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rcParams
from tqdm import tqdm
from EmpiricalData import ExtracAidFoS


# 以下三项任务 (将被其它模块调用)
# (1) 过滤 低频FoS
# (2) 统计 FoS, FoS tuple, bi-FoS 的出生时刻
# (3) 计算 计算标准化引用的所需要的 mean 和 std


#%%
field_name = "computer science"
mag_papers_meta_cs = ExtracAidFoS.mag_papers_meta_cs
process_data_path = ExtracAidFoS.process_data_path

i_list = ['0.0', '0.1', '0.2', '0.3'] + list(np.arange(1, 11))
filter_threshold = 1000  # 低于该阈值的fos被过滤掉
bornyear_threshold = 10  # 首次超过该阈值的时间是fos的出生时刻


# 读取数据模块
def fos_data(i):
    # 读取aid2pid 每篇文章的fos_list
    with open(os.path.join(process_data_path, "aid2fos_{}.pkl".format(i)), 'rb') as f:
        aid2fos = pickle.load(f)
    return aid2fos


def filter_fos_data(filterfos2bornyear, i):
    # 通过 filterfos2bornyear过滤FoS
    # 读取 aid_part2fos_{}, 由ExtractAIdFoS.py
    aid2fos = fos_data(i)
    #  aid2fos ---> 过滤得到 aid2fosidx (只保留大于特定频率的fos)
    Keys = list(aid2fos.keys())
    aid2fosidx = dict()
    for aid in tqdm(Keys):
        aid2fosidx[aid] = dict()
        for year in aid2fos[aid]:
            aid2fosidx[aid][year] = list()
            for pid, fos_list in aid2fos[aid][year]:
                filterfos_list = list()
                for fos in fos_list:
                    if fos not in filterfos2bornyear:
                        continue
                    idx = str(fos)
                    filterfos_list.append(idx)
                    
                # 排序 --- 保证组合命名唯一
                filterfos_list = list(set(filterfos_list))
                filterfos_list = [int(fos) for fos in filterfos_list]
                filterfos_list = list(sorted(filterfos_list))
                filterfos_list = [str(fos) for fos in filterfos_list]    
            
                aid2fosidx[aid][year].append((pid, filterfos_list))
        del aid2fos[aid]

    return aid2fosidx


def fos_born_year_data(filter_threshold):
    # 读取 fos 和 fos tuple的出生年份 --- 由FoSFilter.py中filter_fos_threshold函数生成
    with open(os.path.join(process_data_path, "filterfos2bornyear_{}.pkl".format(filter_threshold)), 'rb') as f:
        filterfos2bornyear = pickle.load(f)
    with open(os.path.join(process_data_path, "filterfostuple2bornyear_{}.pkl".format(filter_threshold)), 'rb') as f:
        filterfostuple2bornyear = pickle.load(f)
    with open(os.path.join(process_data_path, "filterbifos2bornyear_{}.pkl".format(filter_threshold)), 'rb') as f:
        filterbifos2bornyear = pickle.load(f)
    
    print("{}个unique fos".format(len(filterfos2bornyear)))
    print("{}个unique fos tuple".format(len(filterfostuple2bornyear)))
    print("{}个unique bifos".format(len(filterbifos2bornyear)))
    
    # 检查 fos tuple只有过滤后的高频fos (通过)
    # for fostuple in tqdm(filterfostuple2bornyear):
    #     for fos in fostuple.split(','):
    #         if int(fos) not in filterfos2bornyear:
    #             print("Wrong fos")
    
    # 检查 fostuple .join时候 是否排序 (通过)
    # temp = list()
    # for fostuple in tqdm(filterfostuple2bornyear):
    #     fostuple = fostuple.split(',')
    #     fostuple = [int(fos) for fos in fostuple]
    #     fostuple = sorted(fostuple)
    #     fostuple = [str(fos) for fos in fostuple]
    #     fostuplename = ','.join(fostuple)
    #     temp.append(fostuplename)
    # assert len(temp) == len(filterfostuple2bornyear)
    
    return filterfos2bornyear, filterfostuple2bornyear, filterbifos2bornyear


def fos_cc_data(i):
    # 读取aid2pid的引用计数
    # 引用部分未拆分为4块
    if i in ['0.0', '0.1', '0.2', '0.3']:
        i = 0
    with open(os.path.join(process_data_path, "aid2cc_{}.pkl".format(i)), 'rb') as f:
       pid2cc = pickle.load(f)
    return pid2cc


def normalized_cc_data():
    # with open(abs_path + "StatisticalData/pubyear2cclist.pkl", 'rb') as f:
    #     pubyear2cclist = pickle.load(f)
    with open(os.path.join(process_data_path, "pubyear2cc_mean_std.pkl"), 'rb') as f:
        pubyear2cc_mean_std = pickle.load(f)
    return pubyear2cc_mean_std
   
    
#%%
# 生成数据模块
def Generate_filterfos_bornyear():
    # 计算fos_born_year_data所需数据
    # (0) 发文量少于filter_threshold的FoS过滤
    # (1) 生成 filterfos2bornyear:      FoS的出生年份
    # (2) 生成 filterfostuple2bornyear: 一篇文章FoS组合的出生年份
    # (3) 生成 filterbifos2bornyear:    bi-FoS (FoS_i, FoS_j)的出生年份

    
    # i_list 标记所有作者的文章的fos_list
    fos2nop = dict()  # 每个fos的频率
    pid_duplicate_dict = dict()
    for i in i_list:
        aid2fos = fos_data(i)
        for aid in tqdm(aid2fos):
            for year in aid2fos[aid]:
                for pid, fos_list in aid2fos[aid][year]:
                    if pid not in pid_duplicate_dict:   # 由于aid_part2fos是作者划分, 避免pid重复计数
                        pid_duplicate_dict[pid] = 0
                    else:
                        continue
                    for fos in fos_list:
                        if fos not in fos2nop:
                            fos2nop[fos] = 1
                        else:
                            fos2nop[fos] += 1
    sortedfos = [(fos, fos2nop[fos]) for fos in fos2nop]
    sortedfos = sorted(sortedfos, key=lambda x: x[-1], reverse=True)
    
    # 审稿人问为什么选取1000过滤FoS
    nop_sum = 0
    nop_sum_over = 0
    for _, nop in sortedfos:
        if nop > 1000:
            nop_sum_over += nop
        nop_sum += nop
    print("Ratio: {}".format(nop_sum_over / nop_sum))
    
    # (0) 过滤保留超过 filter_threshold 的 fos
    filterfos = list()
    for fos_idx, nop in sortedfos:
        if nop < filter_threshold:
            break
        else:
            # fos_name = idx2fos[fos_idx]
            filterfos.append(fos_idx)
    with open(os.path.join(process_data_path, "filterfos_{}.pkl".format(filter_threshold)), 'wb') as f:
        pickle.dump(filterfos, f)
    print("阈值为{}, 过滤后有{}个FoS".format(filter_threshold, len(filterfos)))
        
    # (1) 统计以上 filterfos 的首次出现年份 (统计 jump 行为, 计算novelty index)
    filterfos2bornyear = dict()
    for fos in filterfos:
        filterfos2bornyear[fos] = -1
    fos2yearlynop = dict()
    pid_duplicate_dict = dict()
    for i in i_list:
        aid2fosidx = filter_fos_data(filterfos2bornyear, i)  # 作者每篇文章的 fos_list
        for aid in tqdm(aid2fosidx):
            for year in aid2fosidx[aid]:
                for pid, fos_list in aid2fosidx[aid][year]:
                    if pid not in pid_duplicate_dict:        # 由于aid_part2fos是作者划分, 避免pid重复计数
                        pid_duplicate_dict[pid] = 0
                    else:
                        continue
                    for fos in fos_list:
                        # 发文量计数
                        if fos not in fos2yearlynop:
                           fos2yearlynop[fos] = dict()
                        if year not in fos2yearlynop[fos]:
                           fos2yearlynop[fos][year] = np.array([0.0, 0.0])  # 全计数, 分数计数
                        fullcount = 1
                        fraccount = 1 / len(fos_list)
                        fos2yearlynop[fos][year] += np.array([fullcount, fraccount])
    assert len(fos2yearlynop) == len(filterfos2bornyear)                  
    # 统计 filter fos 超过 bornyear_threshold的时刻作为 bornyear
    # 计数FoS的出生年份 (累计采纳频次超过 bornyear_threshold)
    for fos in filterfos2bornyear:
        time_list = list(fos2yearlynop[str(fos)].keys())
        if '' in time_list:
            time_list.remove('')
        time_list = sorted(time_list)
        accumulative_fullcount = 0
        accumulative_fraccount = 0
        for year in time_list:
            fullcount, fraccount = fos2yearlynop[str(fos)][year]
            accumulative_fullcount += fullcount
            accumulative_fraccount += fraccount
            if accumulative_fullcount > bornyear_threshold:
                filterfos2bornyear[fos] = year 
                break
    with open(os.path.join(process_data_path, "filterfos2bornyear_{}.pkl".format(filter_threshold)) , 'wb') as f:
        pickle.dump(filterfos2bornyear, f)
    
    
    # (2) 统计新组合出现年份, 统计 new combination 行为
    filterfostuple2bornyear = dict()
    pid_duplicate_dict = dict()
    for i in i_list:
        aid2fosidx = filter_fos_data(filterfos2bornyear, i)  # 作者每篇文章的 fos_list
        for aid in tqdm(aid2fosidx):
            for year in aid2fosidx[aid]:
                if year == '':
                    continue
                for pid, fos_list in aid2fosidx[aid][year]:
                    if pid not in pid_duplicate_dict:        # 由于aid_part2fos是作者划分, 避免pid重复计数
                        pid_duplicate_dict[pid] = 0
                    else:
                        continue
                   
                    if len(fos_list) != 0:  # 过滤后非空
                       fos_tuple_name = ",".join(fos_list)
                       # 确定组合最早出现的年份
                       if fos_tuple_name not in filterfostuple2bornyear:
                           filterfostuple2bornyear[fos_tuple_name] = year
                       else:
                           temp_value = filterfostuple2bornyear[fos_tuple_name]
                           filterfostuple2bornyear[fos_tuple_name] = min(year, temp_value) 
    with open(os.path.join(process_data_path, "filterfostuple2bornyear_{}.pkl".format(filter_threshold)), 'wb') as f:
        pickle.dump(filterfostuple2bornyear, f)

      
    # (3) 统计fos二元组出现年份, 用于计算探索性
    filterbifos2bornyear = dict()
    pid_duplicate_dict = dict()
    for i in i_list:
        aid2fosidx = filter_fos_data(filterfos2bornyear, i)  # 作者每篇文章的 fos_list
        for aid in tqdm(aid2fosidx):
            for year in aid2fosidx[aid]:
                if year == '':
                    continue
                for pid, fos_list in aid2fosidx[aid][year]:
                    if pid not in pid_duplicate_dict:        # 由于aid_part2fos是作者划分, 避免pid重复计数
                        pid_duplicate_dict[pid] = 0
                    else:
                        continue
                    if len(fos_list) > 1:  # 过滤后非空, 至少有2个fos
                        # C_n^2
                        for fos_i_index, fos_i in enumerate(fos_list):
                            for fos_j_index, fos_j in enumerate(fos_list[fos_i_index+1:]):
                                bi_fos_name = ",".join([fos_i, fos_j])
                                # 确定元组最早出现的年份
                                if bi_fos_name not in filterbifos2bornyear:
                                   filterbifos2bornyear[bi_fos_name] = year
                                else:
                                   temp_year = filterbifos2bornyear[bi_fos_name]
                                   filterbifos2bornyear[bi_fos_name] = min(year, temp_year) 
    with open(os.path.join(process_data_path, "filterbifos2bornyear_{}.pkl".format(filter_threshold)), 'wb') as f:
        pickle.dump(filterbifos2bornyear, f)


def Create_normalizedcc_mean_std():
    # 计算 normalized cc 需要的 mean_cc_t, std_cc_t
    
    # (1) 确定每篇文章的publication year
    pid2pubyear = dict()
    for i in tqdm(i_list):
        aid2fosidx = fos_data(i)  # 作者每篇文章的 fos_list
        for aid in aid2fosidx:
            for year in aid2fosidx[aid]:
                for pid, fos_list in aid2fosidx[aid][year]:
                    pid2pubyear[pid] = year

    # (2) 确定每年的所有文章的 cc_list
    pubyear2cclist = dict()
    for i in tqdm(i_list):
        pid2cc  = fos_cc_data(i)
        for pid in pid2cc:
            # 出版年份
            pubyear = pid2pubyear[pid]
            # 引用数目
            total_cc = 0
            for year in pid2cc[pid]:
                total_cc += pid2cc[pid][year]
            # 
            if pubyear not in pubyear2cclist:
                pubyear2cclist[pubyear] = list()
            pubyear2cclist[pubyear].append(total_cc)
    # 
    if '' in pubyear2cclist:
        del pubyear2cclist['']
    year_list = list(sorted(pubyear2cclist.keys()))
    
    # (3) 计算 cc_list的均值和标准差
    pubyear2cc_mean_std = dict()
    for year in tqdm(year_list):
        cc_list_t = pubyear2cclist[year]
        mean_cc_t = np.mean(cc_list_t)
        std_cc_t  = np.std(cc_list_t)
        pubyear2cc_mean_std[year] = (mean_cc_t, std_cc_t)
    # 
    with open(os.path.join(process_data_path, "pubyear2cclist.pkl"), 'wb') as f:
        pickle.dump(pubyear2cclist, f)
    with open(os.path.join(process_data_path, "pubyear2cc_mean_std.pkl"), 'wb') as f:
        pickle.dump(pubyear2cc_mean_std, f)
    
    
#%%
def Main():
    # FoS初年年份相关信息, 计算Novel Index相关指标需要
    Generate_filterfos_bornyear()
    # Normarliaed citation count, 同年文章的citation count的mean 和 std
    Create_normalizedcc_mean_std()