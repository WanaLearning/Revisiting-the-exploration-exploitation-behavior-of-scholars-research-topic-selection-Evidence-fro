# -*- coding: utf-8 -*-
"""
Created on Sat Aug 14 10:45:26 2021

@author: ShengzhiHuang
"""
import numpy as np


#%%
class TSP():
    
    def __init__(self, data, c_rate=0.7, m_rate=0.05, pop_size=20, ga_num=150):
        
        # 超参数 (遗传算法)
        self.c_rate = c_rate                   # 交叉率
        self.m_rate = m_rate                   # 突变率
        self.pop_size = pop_size               # 种群大小
        self.ga_num = ga_num                   # 最大迭代次数
        self.best_dist = 1e6                   # 记录目前最优距离
        
        # 数据源
        self.citys = data                      # point: (x, y) 
        self.city_size = len(data)             # number of points   
        
        # 种群初始化
        self.pop = self.create_pop(self.pop_size)      # 初始化创建种群
        self.fitness = self.caculate_fitness(self.pop) # 初始化种群适应度
       
    def caculate_total_distance(self, gene):
        # 计算基因所代表路径的总欧氏距离
        distance = 0
        for i, _ in enumerate(gene):
            if i + 1 == len(gene) :
                break
            else:
                index1, index2 = gene[i], gene[i + 1]
                datapoint1, datapoint2 = self.citys[index1], self.citys[index2]
                distance += np.linalg.norm(np.array(datapoint1) - np.array(datapoint2), 2)
        return distance
    
    def caculate_two_points_distance(self, datapoint1, datapoint2):
        #计算2个数据点之间的欧氏距离
        distance = np.linalg.norm(np.array(datapoint1) - np.array(datapoint2), 2)
        return distance

    def create_pop(self, size):
        pop_array = list()
        for i in range(size):
            # 基因序列, 问题的解, 城市间的任意一条路径
            gene = np.arange(self.city_size)
            # 取出中间路径  2021-8-21只洗牌中间路径
            gene_middle = gene[1: -1]
            # 洗牌基因
            np.random.shuffle(gene_middle)
            # 加入种群
            pop_array.append(gene)            
        return np.array(pop_array)

    def caculate_fitness(self, pop):
        fitness_array = list()
        for gene in pop:
            # 计算此基因优劣（距离长短）
            distance = self.caculate_total_distance(gene)
            # 当前最优距离除以当前pop[i]（个体）距离；越近适应度越高，最优适应度为1
            fitness = self.best_dist / distance    
            fitness_array.append(fitness)
        return np.array(fitness_array)

    def get_local_fitness(self, gen, i):
        '''
        计算第i个城市的邻域
        交换基因数组中任意两个值组成的解集：称为邻域。计算领域内所有可能的适应度
        :param gen:城市路径
        :param i:第i城市
        :return:第i城市的局部适应度
        '''
        di = 0
        fi = 0
        if i == 0:
            di = self.caculate_two_points_distance(self.citys[gen[0]], self.citys[gen[-1]])
        else:
            di = self.caculate_two_points_distance(self.citys[gen[i]], self.citys[gen[i - 1]])
        od = []
        for j in range(self.city_size):
            if i != j:
                od.append(self.caculate_two_points_distance(self.citys[gen[i]], self.citys[gen[i - 1]]))
        mind = np.min(od)
        fi = di - mind
        return fi

    def EO(self, gen):
        '''
        极值优化，传统遗传算法性能不好，这里混合EO
        其会在整个基因的领域内，寻找一个最佳变换以更新基因
        '''
        def exechange_gen(gen, i, j):
            #函数：交换基因中i,j值
            c = gen[j]
            gen[j] = gen[i]
            gen[i] = c
            return gen
            
        local_fitness = []
        for g in range(self.city_size):
            f = self.get_local_fitness(gen, g)
            local_fitness.append(f)
        max_city_i = np.argmax(local_fitness)
        maxgen = np.copy(gen)
        if 1 < max_city_i < self.city_size - 1:
            for j in range(max_city_i):
                maxgen = np.copy(gen)
                jj = max_city_i
                while jj < self.city_size:
                    gen1 = exechange_gen(maxgen, j, jj)
                    d = self.caculate_total_distance(maxgen)
                    d1 = self.caculate_total_distance(gen1)
                    if d > d1:
                        maxgen = gen1[:]
                    jj += 1
        
        # 若首尾不对则不要
        if maxgen[0] == 0 and maxgen[-1] == self.city_size - 1:
            gen = maxgen
        
        return gen
    
    def SelectionPop(self, pop, method="average"):
        if method == "average":
            # 策略1：低于平均值的gene要替换改变
            best_fitness_index = np.argmax(self.fitness)
            average_fitness = np.median(self.fitness, axis=0)
        
            for i in range(self.pop_size):
                if i != best_fitness_index and self.fitness[i] < average_fitness:
                    # 当前基因和最优基因杂交
                    new_gene = self.CrossGene(pop[best_fitness_index], pop[i])
                    # 杂交后基因变异
                    new_gene = self.MutateGene(new_gene)
                    # 
                    pop[i] = new_gene
        else:
            # 策略2：轮盘赌，适应度低的替换的概率大
            probility = self.fitness / self.fitness.sum()
            idx = np.random.choice(np.arange(self.pop_size), size=self.pop_size, replace=True, p=probility)
            pop = pop[idx, :]
                    
        return pop
    
    def CrossGene(self, parent1, parent2):
        #交叉p1,p2的部分基因片段
        
        # 此时不交叉
        if np.random.rand() > self.c_rate:
            return parent1
        
        # 确定交叉基因片段
        index1 = np.random.randint(0, self.city_size - 1)
        index2 = np.random.randint(index1, self.city_size - 1)
        temp_gene = parent2[index1:index2]  
        
        new_gene = []
        p1len = 0
        for g in parent1:
            # 插入基因
            if p1len == index1: 
                new_gene.extend(temp_gene)
            # 只添加非交叉段的基因
            if g not in temp_gene:
                new_gene.append(g)
            p1len += 1
        new_gene = np.array(new_gene)
        
        # 程序交叉基因维数出错
        if new_gene.shape[0] != self.city_size:
            print('c error')
            return self.creat_pop(1)
        return new_gene

    def MutateGene(self, gene):
        """突变"""
        # 此时不突变
        if np.random.rand() > self.m_rate:
            return gene
        
        # 确定突变位置 (首尾不会突变, 保证起点终点不变) - 2021-8-21
        index1 = np.random.randint(1, self.city_size - 2)
        index2 = np.random.randint(index1, self.city_size - 1)
        
        # 开始突变, 逆序基因片段
        parent1 = np.copy(gene)
        temp_gene = parent1[index1: index2]
        new_gene = []
        p1len = 0
        for g in parent1:
            if p1len == index1:
                # 插入逆序基因片段
                new_gene.extend(temp_gene[::-1])  
            if g not in temp_gene:
                new_gene.append(g)
            p1len += 1
        new_gene = np.array(new_gene)
        
        # 程序交叉基因维数出错
        if new_gene.shape[0] != self.city_size:
            print('m error')
            return self.creat_pop(1)
        return new_gene

    def StartEvolution(self):
        # 主程序：迭代进化种群
        for i in range(self.ga_num):
            best_fitness_index = np.argmax(self.fitness)
            worst_fitness_index = np.argmin(self.fitness)
            local_best_gene = self.pop[best_fitness_index]
            local_best_dist = self.caculate_total_distance(local_best_gene)
            
            if i == 0:
                # 记录首次迭代的最优基因
                self.best_gene = local_best_gene    
                # 记录该最优基因的fitness
                self.best_dist = local_best_dist

            if local_best_dist < self.best_dist:
                # i + 1次迭代产生更优的基因
                self.best_gene = local_best_gene
                self.best_dist = local_best_dist
            else:
                # 将最差的基因替换为最好的基因
                self.pop[worst_fitness_index] = self.best_gene
            
            # 输出第i次迭代的最优基因的fitness value
            # print('gen:%d evo,best dist :%s' % (i, self.best_dist))
            
            # 选择淘汰种群 (当前和最优基因交互)
            self.pop = self.SelectionPop(self.pop)
            # 计算种群适应度
            self.fitness = self.caculate_fitness(self.pop)
            # 种群交叉变异
            for j in range(self.pop_size):
                r = np.random.randint(0, self.pop_size - 1)
                if j != r:
                    # 交叉种群中第j, r个体的基因
                    self.pop[j] = self.CrossGene(self.pop[j], self.pop[r])    
                    # 突变种群中第j个体的基因
                    self.pop[j] = self.MutateGene(self.pop[j])    
            
            # 极值优化，防止收敛局部最优
            # self.best_gene = self.EO(self.best_gene)    
            # #记录最优值
            self.best_dist = self.caculate_total_distance(self.best_gene)
        
        
def TSP_EXAMPLE():
    # CITY DATA FOR EXAMPLE
    CityData = (("北京", 116.46, 39.92), 
                ("天津", 117.20, 39.13),
                ("上海", 121.48, 31.22),
                ("重庆", 106.54, 29.59),
                ("拉萨", 91.11, 29.97),
                ("乌鲁木齐", 87.68, 43.77),
                ("银川", 106.27, 38.47),
                ("呼和浩特", 111.65, 40.82),
                ("南宁", 108.33, 22.84),
                ("哈尔滨", 126.63, 45.75),
                ("长春", 125.35, 43.88),
                ("沈阳", 123.38, 41.8),
                ("石家庄", 114.48, 38.03),
                ("太原", 112.53, 37.87),
                ("西宁", 101.74, 36.56),
                ("济南", 117, 36.65),
                ("郑州", 113.6, 34.76),
                ("南京", 118.78, 32.04),
                ("合肥", 117.27, 31.86),
                ("杭州", 120.19, 30.26),
                ("福州", 119.3, 26.08),
                ("南昌", 115.89, 28.68),
                ("长沙", 113, 28.21),
                ("武汉", 114.31, 30.52),
                ("广州", 113.23, 23.16),
                ("台北", 121.5, 25.05),
                ("海口", 110.35, 20.02),
                ("兰州", 103.73, 36.03),
                ("西安", 108.95, 34.27),
                ("成都", 104.06, 30.67),
                ("贵阳", 106.71, 26.57),
                ("昆明", 102.73, 25.04),
                ("香港", 114.1, 22.2),
                ("澳门", 113.33, 22.13))
    
    data = np.array([i[1:] for i in CityData])
    # Genetic algorithm
    tsp = TSP(data, 0.5, 0.1, 100, 500)
    tsp.StartEvolution()
    # optimal path
    print(tsp.best_gene)

#%%
def get_optimal_path(P):
    '''
    Parameters
    ----------
    P : np.array()
        d x N matrix.

    Returns
    -------
    optimal_path : np.array()
        opitmial path.

    '''
    d, N = P.shape
    data = np.transpose(P)
    
    # 枚举求解
    if N == 4:
        tsp = TSP(data)
        
        real_distance = tsp.caculate_total_distance(np.array([0, 1, 2, 3]))
        alter_distance = tsp.caculate_total_distance(np.array([0, 2, 1, 3]))
        if real_distance > alter_distance:
            optimal_path = np.array([0, 2, 1, 3])
        else:
            optimal_path = np.array([0, 1, 2, 3])
    elif N == 5:
        tsp = TSP(data)
        
        real_distance = tsp.caculate_total_distance(np.array([0, 1, 2, 3, 4]))
        alter_distance1 = tsp.caculate_total_distance(np.array([0, 1, 3, 2, 4]))
        alter_distance2 = tsp.caculate_total_distance(np.array([0, 2, 1, 3, 4]))
        alter_distance3 = tsp.caculate_total_distance(np.array([0, 2, 3, 1, 4]))
        alter_distance4 = tsp.caculate_total_distance(np.array([0, 3, 1, 2, 4]))
        alter_distance5 = tsp.caculate_total_distance(np.array([0, 3, 2, 1, 4]))
        
        total_alter = [real_distance, alter_distance1, alter_distance2,
                       alter_distance3, alter_distance4, alter_distance5]
        
        if real_distance == min(total_alter):
            optimal_path = np.array([0, 1, 2, 3, 4])
        elif alter_distance1 == min(total_alter):
            optimal_path = np.array([0, 1, 3, 2, 4])
        elif alter_distance2 == min(total_alter):
            optimal_path = np.array([0, 2, 1, 3, 4])
        elif alter_distance3 == min(total_alter):
            optimal_path = np.array([0, 2, 3, 1, 4])    
        elif alter_distance4 == min(total_alter):
            optimal_path = np.array([0, 3, 1, 2, 4])
        else:
            optimal_path = np.array([0, 3, 2, 1, 4])
    else:
        if N == 6: 
            # 全排列 24 种
            tsp = TSP(data, pop_size=20, ga_num=20)
        elif N == 7:
            # 全排列 120 种
            tsp = TSP(data, pop_size=20, ga_num=40)
        else:
            tsp = TSP(data)
        # 遗传算法求解
        tsp.StartEvolution()
        optimal_path = tsp.best_gene
        
    
    return optimal_path, tsp


def CaculateCircutousnessMetrics(P):
    d, N = P.shape
    # 真实路径
    real_path = np.arange(N)
    # 最优路径
    optimal_path, tsp = get_optimal_path(P)
    # 计算真实路径长度 / 最优路径长度
    real_distance = tsp.caculate_total_distance(real_path)
    optimal_distance = tsp.caculate_total_distance(optimal_path)
    
    ratio = real_distance / optimal_distance
    
    return ratio
    
